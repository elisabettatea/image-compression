
# Image Filtering and Denoising 🧠🖼️

Welcome to Challenge 1 of the **Numerical Linear Algebra** course (Politecnico di Milano, A.A. 2024/2025)!  
In this project, we apply tools from linear algebra—particularly sparse matrices and iterative solvers—to the task of image filtering and denoising.  
Through a hands-on implementation in C++, we explore how common image processing tasks such as blurring, sharpening, and edge detection can be modeled as matrix-vector operations, and how solving linear systems can be used to restore noisy images.

---

## 🧾 Project Goal

Given a grayscale image, we:

1. Add artificial noise.
2. Apply convolution filters (blur/smooth, sharpen, edge detect).
3. Solve large sparse linear systems (using Eigen and LIS solvers).
4. Reconstruct denoised images from computed solutions.

All operations are done on flattened image vectors, making this an ideal exercise in **sparse matrix construction**, **iterative solvers**, and **filter interpretation** in a numerical linear algebra context.

---

## 📁 Project Structure

```bash
image-filtering/
├── README_Challenge1.md
├── src/
│   ├── image-filtering.cpp         # Main C++ source file
│   ├── stb_image.h                 # Header for image reading
│   └── stb_image_write.h           # Header for image writing
├── images/
│   └── einstein.jpg                # Input grayscale image (341x256)
├── output images/
│   ├── output_noise.png            # Image with added noise
│   ├── output_smooth.png           # Smoothed image (blur)
│   ├── output_sharp.png            # Sharpened image
│   ├── output_edge.png             # Edge detection output
│   ├── x_image.png                 # Denoised image (A2x = w)
│   └── y_image.png                 # Denoised image ((I + A3)y = w)
├── matrices/
│   ├── A2.mtx                      # Matrix for sharpening filter
│   ├── w.mtx                       # Noisy image vector
│   └── sol.txt                     # Solution to A2x = w
```

---

## 🛠️ Setup & Dependencies

- C++17 compiler (e.g., g++)
- [Eigen](https://eigen.tuxfamily.org/) for sparse matrix/vector computations
- [STB](https://github.com/nothings/stb) single-header image I/O
- LIS (Library of Iterative Solvers) for solving large systems externally

To build and run:

```bash
g++ src/image-filtering.cpp -o image_filter -std=c++17
./image_filter images/einstein.jpg
```

To run LIS (external solver):

```bash
mpirun -n 4 ./test1 matrices/A2.mtx matrices/w.mtx matrices/sol.txt hist.txt -i gmres -p ssor -tol 1.0e-9
```

---

## 🔬 Overview of Methods

### 🔹 1. Image Representation

- The image is loaded as a grayscale matrix \( F \in \mathbb{R}^{m 	imes n} \) and then reshaped into a vector \( v \in \mathbb{R}^{mn} \).
- A noisy version \( w \) is generated by adding random noise in the range \([-50, +50]\) to each pixel.

---

### 🔹 2. Smoothing via Convolution (Hav2)

We apply a blur using the kernel:

\[
H_{av2} = rac{1}{9}
\begin{bmatrix}
1 & 1 & 1 \\
1 & 1 & 1 \\
1 & 1 & 1
\end{bmatrix}
\]

- Construct sparse matrix \( A_1 \in \mathbb{R}^{mn 	imes mn} \) implementing this convolution.
- Perform smoothing with matrix-vector product: `A1 * w`.

📄 Result: `output_smooth.png`

---

### 🔹 3. Sharpening via Convolution (Hsh2)

We sharpen the image using:

\[
H_{sh2} =
\begin{bmatrix}
0 & -3 & 0 \\
-1 & 9 & -3 \\
0 & -1 & 0
\end{bmatrix}
\]

- This corresponds to a sharpening filter matrix \( A_2 \).
- Apply sharpening as \( A_2 v \).

📄 Result: `output_sharp.png`

- Symmetric? ❌  
- Non-zero entries: 435,286

---

### 🔹 4. Edge Detection via Laplacian Filter

Using the discrete Laplacian kernel:

\[
H_{lap} =
\begin{bmatrix}
0 & -1 & 0 \\
-1 & 4 & -1 \\
0 & -1 & 0
\end{bmatrix}
\]

We define \( A_3 \) to apply this operation: `A3 * v`.

📄 Result: `output_edge.png`

- Symmetric? ✅

---

### 🔹 5. Solving Linear Systems

#### a) Solve \( A_2 x = w \)

- Matrix `A2.mtx`, vector `w.mtx`
- Solved externally with LIS using GMRES:
    - Iterations: 20
    - Final residual: 4.26e−10

📄 Output: `x_image.png` → Denoised version of noisy image

#### b) Solve \( (I + A_3)y = w \)

- Done with Eigen's Conjugate Gradient method
- Iterations: 32
- Final residual: 7.38e−11

📄 Output: `y_image.png`

---

## 📷 Output Gallery

<div align="center">

| Step                  | Output                               |
|-----------------------|--------------------------------------|
| Original              | ![](./images/einstein.jpg)           |
| Noisy Image           | ![](./output%20images/output_noise.png)|
| Smoothed (Hav2)       | ![](./output%20images/output_smooth.png)|
| Sharpened (Hsh2)      | ![](./output%20images/output_sharp.png)|
| Edge Detection (Hlap) | ![](./output%20images/output_edge.png) |
| Denoised (A₂x = w)    | ![](./output%20images/y_image.png)     |
| Denoised ((I+A₃)y=w)  | ![](./output%20images/y_image.png)     |

</div>

---

## 🔚 Conclusion

This project demonstrates how familiar image processing operations can be translated into **linear algebraic formulations**:

- Filters ↔ Sparse matrices  
- Pixels ↔ Vector entries  
- Denoising ↔ Solving systems  

The results confirm that solving these systems yields meaningful transformations like noise removal and edge enhancement—core tools in computer vision and image analysis.

---

## 💬 Questions?

📧 elisabetta.tea@gmail.com

Enjoy filtering, solving, and visualizing! 🎨
